/*
Copyright (c) 2023 Emerson Clarke <ZeroToHero>

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
#pragma once




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#include "hero/bit.h"





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef HERO_PLATFORM_WINDOWS







#endif

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


namespace Hero {
	class Stream;
	class String;
	class Substring;
	class Superstring;
	class Characters;
	class Object;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



namespace Hero {


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




char		ClampDiffSigned(long long lhs, long long rhs, char min, char max);
short		ClampDiffSigned(long long lhs, long long rhs, short min, short max);
int			ClampDiffSigned(long long lhs, long long rhs, int min, int max);
long		ClampDiffSigned(long long lhs, long long rhs, long min, long max);
long long	ClampDiffSigned(long long lhs, long long rhs, long long min, long long max);



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



template<typename _To_,typename _From_>
class Clamp
{
public:

	

	static const _To_ Min = -(1LL<<(sizeof(_To_)*8-1));		
	static const _To_ Max = (1LL<<(sizeof(_To_)*8-1))-1;	

	
	static _To_ Diff(_From_ lhs, _From_ rhs)
	{
		long long difference = (long long)lhs-(long long)rhs;
		_To_ diff = (_To_)(difference);
		
		
		return ((long long)(diff) == difference)?diff:(difference<0)?Min:Max;
	}	
};



template<typename _To_>
class Clamp<_To_,long long>
{
public:

	static const _To_ Min = -(1LL<<(sizeof(_To_)*8-1));		
	static const _To_ Max = (1LL<<(sizeof(_To_)*8-1))-1;	

	
	static _To_ Diff(long long lhs, long long rhs)
	{
		
		
		
		
		
		
		
		_To_ diff = ClampDiffSigned(lhs,rhs,Min,Max);
		return diff;
	}
};


template<>
class Clamp<int,void*>
{
public:

	static const int Min = -(1LL<<(sizeof(int)*8-1));	
	static const int Max = (1LL<<(sizeof(int)*8-1))-1;	

	
	static int Diff(void* lhs, void* rhs)
	{
		long long difference = (long long)lhs-(long long)rhs;
		int diff = (int)(difference);
		
		
		return ((long long)(diff) == difference)?diff:(difference<0)?Min:Max;
	}
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


class Orderable
{
public:

	
	
	
	
	enum Order
	{
		ORDER_DEFAULT		=(0),			
		ORDER_ASCENDING		=(1),			
		ORDER_DESCENDING	=(1)<<1,		
		ORDER_POLICY		=(1)<<2,		
	};
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


class Placeable
{
public:

	
	
	
	
	
	enum Place
	{
		PLACE_AFTER			=(0),			
		PLACE_BEFORE		=(1),			
		PLACE_RANDOM		=(1)<<1,		
		PLACE_ASCENDING		=(1)<<2,		
		PLACE_DESCENDING	=(1)<<3,		
		PLACE_POLICY		=(1)<<4,		
	};

	
	class Placement : public Flags<8>
	{
	public:

		
		Placement(const Place place):Flags<8>(place){};
		Placement(const unsigned char place):Flags<8>(place){};

		bool IsAfter(){return Is(PLACE_AFTER);};
		bool IsBefore(){return Is(PLACE_BEFORE);};
		bool IsRandom(){return Is(PLACE_RANDOM);};
	};

};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Direction
{
public:

	enum Directions
	{
		DIRECTION_NONE	=(0),
		DIRECTION_LEFT	=(-1),
		DIRECTION_RIGHT	=(1),
		DIRECTION_UP	=(2),
		DIRECTION_DOWN	=(-2),

		DIRECTION_APPEND	= DIRECTION_RIGHT,
		DIRECTION_PREPEND	= DIRECTION_LEFT,
		DIRECTION_POSITIVE	= DIRECTION_RIGHT,
		DIRECTION_NEGATIVE	= DIRECTION_LEFT,
	};
};



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Comparable
{
public:

	
	
	

	enum Comparison	
	{
		COMPARE_GENERAL		=(0),		
		COMPARE_PRECISE		=(1),		
		COMPARE_INSTANCE	=(1)<<1,	
		COMPARE_POLICY		=(1)<<2,	

		

		COMPARE_OPTION_A	=(1)<<8,
		COMPARE_OPTION_B	=(1)<<9,
		COMPARE_OPTION_C	=(1)<<10,
		COMPARE_OPTION_D	=(1)<<11,
		COMPARE_OPTION_E	=(1)<<12,
		COMPARE_OPTION_F	=(1)<<13,

	};

	
	class Comparitor : public Flags<8>
	{
	public:

		

		Comparitor(unsigned char mask) : Flags<8>(mask){}
		Comparitor() : Flags<8>(COMPARE_GENERAL){}

		bool IsGeneral(){return Is(COMPARE_GENERAL);};
		bool IsPrecise(){return Is(COMPARE_PRECISE);};
		bool IsInstance(){return Is(COMPARE_INSTANCE);};

	};

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



template <typename _Kind_>
class Comparer : public Comparable
{
public:

	typedef int (*CompareFunction)(const _Kind_ & left, const _Kind_ & right, int comparitor);
	

	static int Compare(_Kind_ & left, _Kind_ & right, int comparitor = COMPARE_GENERAL)
	{
		return Identify<_Kind_>(*(_Kind_*)(&left),*(_Kind_*)(&right),comparitor,0);
	}


	static int Compare(const _Kind_ & left, const _Kind_ & right, int comparitor = COMPARE_GENERAL)
	{
		return Identify<_Kind_>(*(_Kind_*)(&left),*(_Kind_*)(&right),comparitor,0);
	}

private:

	template<typename Argument>
	static int Identify(Argument & left, Argument & right, int comparitor, void (Argument::*)())
	{
		return Process(left,right,comparitor,&right);
	}

	template<typename Argument>
	static int Identify(Argument & left, Argument & right, int comparitor, ...)
	{
		return Process(left,right,comparitor,right);
	}


	static int Process(_Kind_ & left, _Kind_ & right, int comparitor, Object *)
	{
		return left.Compare(&right,comparitor);
	}

	static int Process(_Kind_ & left, _Kind_ & right, int comparitor, void *)
	{

		
		return Clamp<int,void *>::Diff(&left,&right);
	}


	static int Process(_Kind_ & left, _Kind_ & right, int comparitor, ...)
	{
		
		

		if (comparitor == Comparable::COMPARE_INSTANCE) return Clamp<int,void*>::Diff(&left,&right);		
		return Clamp<int,_Kind_>::Diff(left,right);
	}
		
	
	static int Process(long long & left, long long & right, int comparitor, long long)
	{		
		if (comparitor == Comparable::COMPARE_INSTANCE) return Clamp<int,void*>::Diff(&left,&right);		
		return Clamp<int,long long>::Diff(left,right);


		
		
		

		

	}
	
	static int Process(long & left, long & right, int comparitor, long)
	{
		if (comparitor == Comparable::COMPARE_INSTANCE) return Clamp<int,void*>::Diff(&left,&right);		
		return Clamp<int,long>::Diff(left,right);

		
	}	
		
	static int Process(int & left, int & right, int comparitor, int)
	{
		if (comparitor == Comparable::COMPARE_INSTANCE) return Clamp<int,void*>::Diff(&left,&right);		
		return Clamp<int,int>::Diff(left,right);

		
	}		

	static int Process(double & left, double & right, int comparitor, double)
	{
		if (comparitor == Comparable::COMPARE_INSTANCE) return Clamp<int,void*>::Diff(&left,&right);		
		

		
		
		
		
		float compare = (float)(left-right);
		return *((int*)&compare);
	}
};




template<>
class Comparer<char> : public Comparable
{
public:

	static int Compare(char left, char right, int comparitor = COMPARE_GENERAL)
	{
		int diff = (int)left-(int)right;
		return diff;		
	}
};

template<>
class Comparer<short> : public Comparable
{
public:

	static int Compare(short left, short right, int comparitor = COMPARE_GENERAL)
	{
		int diff = (int)left-(int)right;
		return diff;
	}
};

template<>
class Comparer<int> : public Comparable
{
public:

	static int Compare(int left, int right, int comparitor = COMPARE_GENERAL)
	{
		
		
		return Clamp<int,int>::Diff(left,right);
		
		
		
		
		
	}
};

template<>
class Comparer<long> : public Comparable
{
public:

	static int Compare(long left, long right, int comparitor = COMPARE_GENERAL)
	{
		return Clamp<int,int>::Diff(left,right);
		
		
		
	}
};

template<>
class Comparer<long long> : public Comparable
{
public:

	static int Compare(long long left, long long right, int comparitor = COMPARE_GENERAL)
	{
		
		return Clamp<int,long long>::Diff(left,right);
		
		
		
	}
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



int CompareCharacter(char * left, char * right, int comparitor);
int CompareObject(Object * left, Object * right, int comparitor);
int ComparePointer(void * left, void * right, int comparitor);


template <typename _Kind_>
class Comparer<_Kind_ *> : public Comparable
{
public:

	typedef int (*CompareFunction)(const _Kind_ * left, const _Kind_ * right);
	static CompareFunction Function;

	static int Compare(const _Kind_ * left, const _Kind_ * right, int comparitor = COMPARE_GENERAL)
	{
		
		return Process((_Kind_*)left,(_Kind_*)right,comparitor,(_Kind_*)right);
	}

private:

	

	static int Process(_Kind_ * left, _Kind_ * right, int comparitor, Object *)
	{
		return CompareObject((Object*)left,(Object*)right,comparitor);
	}

	static int Process(_Kind_ * left, _Kind_ * right, int comparitor, void *)
	{
		return ComparePointer(left,right,comparitor);
	}

	static int Process(_Kind_ * left, _Kind_ * right, int comparitor, char[])
	{
		return CompareCharacter(left,right,comparitor);
	}

	static int Process(_Kind_ * left, _Kind_ * right, int comparitor, ...)
	{
		
		return (int)((long)left - (long)right);
	}

};

template <typename _Kind_>
typename Comparer<_Kind_*>::CompareFunction Comparer<_Kind_*>::Function=0;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename _Kind_>
class Comparer<_Kind_ &> : public Comparable
{
public:

	typedef int (*CompareFunction)(const _Kind_ & left, const _Kind_ & right);
	static CompareFunction Function;

	static int Compare(const _Kind_ & left, const _Kind_ & right, int comparitor = COMPARE_GENERAL)
	{
		return Identify<_Kind_>((_Kind_&)left,(_Kind_&)right,comparitor,0);
	}

private:


	template<typename Argument>
	static int Identify(Argument & left, Argument & right, int comparitor, void (Argument::*)())
	{
		return Process(left, right, comparitor, &right);
	}

	template<typename Argument>
	static int Identify(Argument & left, Argument & right, int comparitor, ...)
	{
		return Process(left, right, comparitor, right);
	}

	static int Process(_Kind_ & left, _Kind_ & right, int comparitor, Object *)
	{
		return left.Compare(&right,comparitor);
	}


	static int Process(_Kind_ & left, _Kind_ & right, int comparitor, void *)
	{
		return &left - &right;
	}

	static int Process(_Kind_ & left, _Kind_ & right, int comparitor, ...)
	{
		if (comparitor == Comparable::COMPARE_INSTANCE) return &left-&right;
		
		return left-right;
	}

	static int Process(double & left, double & right, int comparitor, double)
	{
		if (comparitor == Comparable::COMPARE_INSTANCE) return &left-&right;

		
		
		
		
		float compare = (float)(left-right);
		return *((int*)&compare);
	}

};

template <typename _Kind_>
typename Comparer<_Kind_&>::CompareFunction Comparer<_Kind_&>::Function=0;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Disposable
{
public:

	
	
	
	enum Dispose
	{
		DISPOSE_NONE	=(0),		
		DISPOSE_POINTER	=(1),		
		DISPOSE_ARRAY	=(1)<<1,	
		DISPOSE_RELEASE =(1)<<2,	
		DISPOSE_DESTROY =(1)<<3,	
		DISPOSE_POLICY	=(1)<<4,	
		
	};

	
	virtual void Release()=0;

	
	virtual void Destroy()=0;

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename _Kind_>
class Disposer 
{
public:

	

	static void Destroy(_Kind_ & type)
	{
		ProcessDestroy(type,&type);
	}

	static void Release(_Kind_ & type)
	{
		ProcessRelease(type,&type);
	}

private:

	static void ProcessDestroy(_Kind_ & type, Disposable *)
	{
	}

	static void ProcessDestroy(_Kind_ & type, ...)
	{
		
	}

	static void ProcessRelease(_Kind_ & type, Disposable *)
	{
	}


	static void ProcessRelease(_Kind_ &type, ...)
	{
		
	}
};



template <typename _Kind_>
class Disposer<_Kind_&>
{
public:

	static void Destroy(_Kind_ & type)
	{
		ProcessDestroy(type,&type);
	}

	static void Release(_Kind_ & type)
	{
		ProcessRelease(type,&type);
	}

private:

	static void ProcessDestroy(_Kind_ & type, Disposable *)
	{
	}

	static void ProcessDestroy(_Kind_ & type, ...)
	{
		
	}

	static void ProcessRelease(_Kind_ & type, Disposable *)
	{
	}


	static void ProcessRelease(_Kind_ &type, ...)
	{
		
	}
};



template <typename _Kind_>
class Disposer<_Kind_ *>
{
public:

	static void Destroy(_Kind_ *& type)
	{
		if (type != 0)
			ProcessDestroy(type,type);
	}

	static void Release(_Kind_ *& type)
	{
		if (type != 0)
			ProcessRelease(type,type);
	}

private:

	static void ProcessDestroy(_Kind_ *& type, Disposable *)
	{

		delete (_Kind_*)type;
		type = 0;
	}

	static void ProcessDestroy(_Kind_ *& type, void *[])
	{
		delete [] type;
		type = 0;
	}

	static void ProcessDestroy(_Kind_ *& type, void *)
	{
		delete (_Kind_*)type;
		type = 0;
	}


	static void ProcessRelease(_Kind_ *& type, Disposable *)
	{
		type = 0;
	}

	static void ProcessRelease(_Kind_ *& type, void *[])
	{
		type = 0;
	}

	static void ProcessRelease(_Kind_ *& type, void *)
	{
		type = 0;
	}
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



class Visitable;

class Visitor
{
public:

	
	virtual ~Visitor()=0;

	
	virtual void Visit(Visitable *visitable){ };	
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



class Visitable
{
public:
	
	virtual void Accept(Visitor *visitor) {visitor->Visit(this);};
};



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Printable
{
public:

	virtual char * Print();
	virtual void Print(String & print)=0;
};




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Serialisable
{
public:

	virtual void Load(Stream &reader)=0;
	virtual void Store(Stream &writer)=0;
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Instantiable
{
public:

	
	void Initialise();
	
	
	void Finalise();
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////







class Growable
{
public:

	
	virtual void Allocate(int amount)=0;

	
	virtual void Reallocate(int amount)=0;	

	
	virtual void Reserve(int amount)=0;

	 
	virtual void Resize(int amount)=0;

	
	virtual void Displace(int amount)=0;

	
	
	

	
	
	
	
	
	
	
	
	

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


class Resizeable
{
public:

	virtual void Allocate(const int amount)=0;
	virtual void Capacity(const int amount)=0;
	virtual void Displace(const int amount)=0;
	virtual void Reserve(const int amount)=0;
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


class Lockable
{
public:

	void Lock();
	void Unlock();
};



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





class Functor
{
public:
	
	template <typename _Kind_> 
	_Kind_ operator() (_Kind_ kind)
	{

	}
};






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





class HashFunctions
{
public:
	
	static int Hash(int value);	
	static int Hash(long value);	
	static int Hash(long long value);
	static int Hash(unsigned int value);
	static int Hash(unsigned long value);
	static int Hash(unsigned long long value);
	static int Hash(float value);
	static int Hash(double value);
	static int Hash(void * value);	
	static int Hash(char * value);
};




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


template <typename _Kind_>
class Hasher
{
public:

	typedef int (*HashFunction)(const _Kind_ & kind);
	static HashFunction Function;

	static int Hash(const _Kind_ & kind)
	{
		return Identify<_Kind_>(*(_Kind_*)(&kind),0);
	}

private:

	template<typename Argument>
	static int Identify(Argument & kind, void (Argument::*)())
	{
		return Process(kind,&kind);
	}

	template<typename Argument>
	static int Identify(Argument & kind, ...)
	{
		return Process(kind,kind);
	}


	static int Process(_Kind_ & kind, Object *)
	{
		return kind.Hash();
	}

	static int Process(_Kind_ & kind, void *)
	{
		
		
		
		return HashFunctions::Hash((void*)&kind);
	}
	
	static int Process(_Kind_ & kind, ...)
	{
		
        
        
        return HashFunctions::Hash(kind);
	}

};

template <typename _Kind_>
typename Hasher<_Kind_>::HashFunction Hasher<_Kind_>::Function=0;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename _Kind_>
class Hasher<_Kind_*>
{
public:

	typedef int (*HashFunction)(const _Kind_ * kind);
	static HashFunction Function;

	static int Hash(const _Kind_ * kind)
	{
		return Identify<_Kind_>((_Kind_*)kind,0);
	}

private:

	template<typename Argument>
	static int Identify(Argument * kind, void (Argument::*)())
	{
		return Process(kind,kind);
	}

	template<typename Argument>
	static int Identify(Argument * kind, ...)
	{
		return Process(kind,kind);
	}

	static int Process(_Kind_ * kind, Object *)
	{
		return kind->Hash();
	}

	static int Process(_Kind_ * kind, void *)
	{
        
        
        
        
        
        
        
		
		return HashFunctions::Hash((void*)kind);
		
	}

	static int Process(_Kind_ * kind, char[])
	{
		return HashFunctions::Hash(kind);		
	}

	static int Process(_Kind_ * kind, ...)
	{
		
		
		
		
        
        
        
        
        return (kind)?HashFunctions::Hash(*kind):0;
	}

};

template <typename _Kind_>
typename Hasher<_Kind_*>::HashFunction Hasher<_Kind_*>::Function=0;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



template <typename _Kind_>
class Hasher<_Kind_&>
{
public:

	typedef int (*HashFunction)(const _Kind_ & kind);
	static HashFunction Function;

	static int Hash(const _Kind_ & kind)
	{
		return Identify<_Kind_>(*(_Kind_*)(&kind),0);
	}

private:

	template<typename Argument>
	static int Identify(Argument & kind, void (Argument::*)())
	{
		return Process(kind,&kind);
	}

	template<typename Argument>
	static int Identify(Argument & kind, ...)
	{
		return Process(kind,kind);
	}


	static int Process(_Kind_ & kind, Object *)
	{
		return kind.Hash();
	}

	static int Process(_Kind_ & kind, void *)
	{
		
		
		
		
		
		
		return HashFunctions::Hash((void*)&kind);
	}
	
	static int Process(_Kind_ & kind, ...)
	{
        
        
        
        return HashFunctions::Hash(kind);
	}

};

template <typename _Kind_>
typename Hasher<_Kind_&>::HashFunction Hasher<_Kind_&>::Function=0;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



template <>
class Hasher<float>
{
public:
	static int Hash(const float & value)
	{
		
		return HashFunctions::Hash(value);
	}
};

template <>
class Hasher<double>
{
public:
	static int Hash(const double & value)
	{
		
		return HashFunctions::Hash(value);
	}
};

template <>
class Hasher<int>
{
public:
	static int Hash(const int & value)
	{
		
		return HashFunctions::Hash(value);
	}
};

template <>
class Hasher<long long>
{
public:
	static int Hash(const long long & value)
	{
		
		return HashFunctions::Hash(value);
	}
};





template <>
class Hasher<void*>
{
public:
	static int Hash(const void *& value)
	{
		
		return HashFunctions::Hash((void*)value);
	}

	static int Hash(void * value)
	{
		return HashFunctions::Hash((void*)value);
	}
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

} 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

