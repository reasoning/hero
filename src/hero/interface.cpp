/*
Copyright (c) 2023 Emerson Clarke <ZeroToHero>

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




#include "hero/interface.h"
#include "hero/structure.h"
#include "hero/number.h"
#include "hero/string.h"
#include "hero/object.h"
#include "hero/signed.h"
#include "hero/error.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace Hero {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#undef min
#undef max


template<typename _To_>
struct ClampType
{
	typedef long long S;
	typedef unsigned long long U;
};

template<>
struct ClampType<long>
{
	typedef long S;
	typedef unsigned long U;
};

template<>
struct ClampType<int>
{
	typedef int S;
	typedef unsigned int U;
};

template<>
struct ClampType<short>
{
	typedef short S;
	typedef unsigned short U;
};

template<>
struct ClampType<char>
{
	typedef char S;
	typedef unsigned char U;
};


template<typename _To_>
_To_ ClampDiffSignedImpl(long long lhs, long long rhs, _To_ min, _To_ max)
{
	
	Signed difference = Signed(lhs)-Signed(rhs);
	int sign = difference.Sign;

	Try t;

	
	
	_To_ diff = difference.ConvertToSignedPrimitive<typename ClampType<_To_>::S,typename ClampType<_To_>::U>();
	
	Catch c;
	if (c) return (sign<0)?min:max;
	
	return diff;
}


char		ClampDiffSigned(long long lhs, long long rhs, char min, char max)			{return ClampDiffSignedImpl<char>(lhs,rhs,min,max);}
short		ClampDiffSigned(long long lhs, long long rhs, short min, short max)			{return ClampDiffSignedImpl<short>(lhs,rhs,min,max);}
int			ClampDiffSigned(long long lhs, long long rhs, int min, int max)				{return ClampDiffSignedImpl<int>(lhs,rhs,min,max);}
long		ClampDiffSigned(long long lhs, long long rhs, long min, long max)			{return ClampDiffSignedImpl<long>(lhs,rhs,min,max);}
long long	ClampDiffSigned(long long lhs, long long rhs, long long min, long long max)	{return ClampDiffSignedImpl<long long>(lhs,rhs,min,max);}






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int CompareCharacter(char * left, char * right, int comparitor)
{
	
	
	
	int leftSize = (int)strlen(left);
	int rightSize = (int)strlen(right);
	return Characters::Compare(left,right,(leftSize<rightSize)?leftSize:rightSize,comparitor);
}

int CompareObject(Object * left, Object * right, int comparitor)
{
	return left->Compare(right,comparitor);
}

int ComparePointer(void * left, void * right, int comparitor)
{
	
	
	#ifdef HERO_PLATFORM_64BIT
	return (int)((long long)left - (long long)right);
	#else
	return (int)((long)left - (long)right);
	#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

char * Printable::Print()
{
	String string;
	Print(string);

	return Printer::Load(string);
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int HashFunctions::Hash(int value) 
{
	return Numbers::Hash(value);
}

int HashFunctions::Hash(long value) 
{
	return Numbers::Hash(value);
}

int HashFunctions::Hash(long long value) 
{
	return Numbers::Hash(value);
}

int HashFunctions::Hash(unsigned int value) 
{
	return Numbers::Hash((int)value);
}

int HashFunctions::Hash(unsigned long value) 
{
	return Numbers::Hash((long)value);
}

int HashFunctions::Hash(unsigned long long value) 
{
	return Numbers::Hash((long long)value);
}


int HashFunctions::Hash(float value) 
{
	return Numbers::Hash(value);
}

int HashFunctions::Hash(double value) 
{
	return Numbers::Hash(value);
}

int HashFunctions::Hash(void * value) 
{
	return Numbers::Hash(value);
}

int HashFunctions::Hash(char * value)
{
	return Characters::Hash(value);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

} 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

